package parsers.statpy;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.HashMap;

parser code
{:
    public void syntax_error(Symbol s){
        main.ParserState.output.add("Error Sintáctico en la Línea " + (s.left) +
                " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    }

    public void unrecovered_syntax_error(Symbol s){ 
        main.ParserState.output.add("Error síntactico irrecuperable en la Línea " + 
                (s.left)+ " Columna "+s.right+". Componente " + s.value + 
                " no reconocido."); 
    }

    String title;
    String titleX;
    String titleY;
    LinkedList<Object> array = new LinkedList<>();
    Object[] valueArray;
    Object[] titleArray;
    HashMap<String, Object> symbol_table = new HashMap<>();
    String key;
    Object value;
:}

terminal LPAREN, RPAREN, ADD, SUB, DIV, TIMES, SEMICOLON, COMMA;
terminal STRING_LITERAL, INTEGER_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL;
terminal STRING, INTEGER, DOUBLE, CHAR, BOOL;
terminal TRUE, FALSE, AND, OR, NOT, ASSIGN, ID;
terminal GREATER, LESS, GREATER_EQUAL, LESS_EQUAL, EQUAL, NOT_EQUAL;
terminal MINUS, PRINT, VOID, MAIN, LBRACKET, RBRACKET;
terminal FOR, INC, WHILE, DO, SWITCH, CASE, DEFAULT, COLON, BREAK;
terminal IF, ELSE;
terminal SQR_BRACKETS, EJEX, VALORES, TITULO, TITULOX, TITULOY;
terminal DEFINIR_GLOBALES, GRAFICA_BARRAS, GRAFICA_PIE;
terminal DOLLAR, NEW_VALOR;

non terminal document, expr, binary_expr, unary_expr;
non terminal expr_literal, arithmetic_expr, relational_expr;
non terminal stmts, stmt, variable_stmt, print_stmt, type;
non terminal for_stmt, while_stmt, do_while_stmt, switch_stmt;
non terminal cases, case, default_case;
non terminal if_stmt, else_stmt, elif_stmt, continue_if;
non terminal define_global_vars, bar_graph, pie_graph;
non terminal bar_graph_body, pie_graph_body, list_definition, list_items;
non terminal bar_graph_options, pie_graph_options, json_value;
non terminal global_vars, var_assignment, var_declaration;

precedence left GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, EQUAL, NOT_EQUAL;
precedence left AND, OR;
precedence left NOT;
precedence left ADD, SUB;
precedence left TIMES, DIV;
precedence left MINUS;

document
::= VOID MAIN LPAREN RPAREN LBRACKET stmts RBRACKET
    {: main.ParserState.output.add("--Parseo finalizado--"); :};

stmts
::= stmts stmt
    |
    stmt;

stmt
::= variable_stmt SEMICOLON
    |
    print_stmt SEMICOLON
    |
    define_global_vars
    |
    bar_graph
    |
    pie_graph
    |
    if_stmt
    |
    for_stmt
    |
    while_stmt
    |
    do_while_stmt SEMICOLON
    |
    switch_stmt
    |
    BREAK SEMICOLON;

define_global_vars
::= VOID DEFINIR_GLOBALES LPAREN RPAREN LBRACKET global_vars RBRACKET;

global_vars
::= global_vars variable_stmt SEMICOLON
    {: symbol_table.put(key.toLowerCase(), value); :}
    |
    variable_stmt SEMICOLON
    {: symbol_table.put(key.toLowerCase(), value); :};

bar_graph
::= VOID GRAFICA_BARRAS LPAREN RPAREN LBRACKET bar_graph_body RBRACKET
    {: graph.general.barras(title, titleX, titleY, valueArray, titleArray); :};

bar_graph_body
::= bar_graph_body bar_graph_options
    |
    bar_graph_options;

bar_graph_options
::= STRING TITULO ASSIGN expr:v SEMICOLON
    {: title = v.toString(); :}
    |
    STRING TITULOX ASSIGN expr:v SEMICOLON
    {: titleX = v.toString(); :}
    |
    STRING TITULOY ASSIGN expr:v SEMICOLON
    {: titleY = v.toString(); :}
    |
    STRING SQR_BRACKETS EJEX ASSIGN list_definition SEMICOLON
    {:
        titleArray = array.toArray();
        array.clear();
    :}
    |
    DOUBLE SQR_BRACKETS VALORES ASSIGN list_definition SEMICOLON
    {:
        valueArray = array.toArray();
        array.clear();
    :};

pie_graph
::= VOID GRAFICA_PIE LPAREN RPAREN LBRACKET pie_graph_body RBRACKET
    {: graph.general.pie(title, valueArray, titleArray); :};

pie_graph_body
::= pie_graph_body pie_graph_options
    |
    pie_graph_options;

pie_graph_options
::= STRING TITULO ASSIGN expr:v SEMICOLON
    {: title = v.toString(); :}
    |
    STRING SQR_BRACKETS EJEX ASSIGN list_definition SEMICOLON
    {:
        titleArray = array.toArray();
        array.clear();
    :}
    |
    DOUBLE SQR_BRACKETS VALORES ASSIGN list_definition SEMICOLON
    {:
        valueArray = array.toArray();
        array.clear();
    :};

list_definition
::= LBRACKET list_items RBRACKET;

list_items
::= list_items COMMA expr:item
    {: array.add(item); :}
    |
    expr:item
    {: array.add(item); :};

variable_stmt
::= var_declaration
    |
    var_assignment;

var_declaration
::= type ID:k ASSIGN expr:v
    {: key = k.toString(); value = v; :}
    |
    type ID:k
    {: key = k.toString(); value = null; :};

var_assignment
::= ID ASSIGN expr;

print_stmt
::= PRINT LPAREN expr:e RPAREN;

if_stmt
::= IF LPAREN expr RPAREN LBRACKET stmts RBRACKET continue_if else_stmt
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET continue_if
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET else_stmt
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET;

continue_if
::= continue_if elif_stmt
    |
    elif_stmt;

elif_stmt
::= ELSE IF LPAREN expr RPAREN LBRACKET stmts RBRACKET;

else_stmt
::= ELSE LBRACKET stmts RBRACKET;

for_stmt
::= FOR LPAREN variable_stmt SEMICOLON expr SEMICOLON ID INC RPAREN LBRACKET stmts RBRACKET;

while_stmt
::= WHILE LPAREN expr RPAREN LBRACKET stmts RBRACKET;

do_while_stmt
::= DO LBRACKET stmts RBRACKET WHILE LPAREN expr RPAREN;

switch_stmt
::= SWITCH LPAREN expr RPAREN LBRACKET cases default_case RBRACKET;

cases
::= cases case
    |
    case;

case
::= CASE expr_literal COLON stmts;

default_case
::= DEFAULT COLON stmts;

type
::= INTEGER:v
    {: RESULT = v; :}
    |
    DOUBLE:v
    {: RESULT = v; :}
    |
    STRING:v
    {: RESULT = v; :}
    |
    CHAR:v
    {: RESULT = v; :}
    |
    VOID:v
    {: RESULT = v; :}
    |
    BOOL:v
    {: RESULT = v; :};

expr
::= binary_expr:v
    {: RESULT = v; :}
    |
    unary_expr:v
    {: RESULT = v; :}
    |
    LPAREN expr:v RPAREN
    {: RESULT = v; :}
    |
    expr_literal:v
    {: RESULT = v; :}
    |
    ID:key
    {:
        try{
            RESULT = symbol_table.get(key.toString().toLowerCase());
        }
        catch(Exception e){
            main.ParserState.output.add("Error en ("+keyleft+", "+keyright+"): "+key.toString()+" no existe");
        }
    :}
    |
    json_value:v
    {: RESULT = v; :};

json_value
::= DOLLAR LBRACKET NEW_VALOR COMMA STRING_LITERAL:file COMMA STRING_LITERAL:key RBRACKET
    {:
        try{
            RESULT = main.ParserState.json_files.get(file.toString()).get(key.toString());
        }
        catch(Exception e){
            main.ParserState.output.add("Error en ("+keyleft+", "+keyright+"): "+key.toString()+" no existe");
        }
    :};

binary_expr
::= arithmetic_expr:v
    {: RESULT = v; :}
    |
    relational_expr:v
    {: RESULT = v; :}
    |
    expr:e1 AND expr:e2
    |
    expr:e1 OR expr:e2;

unary_expr
::= NOT expr:e
    |
    SUB expr:e %prec MINUS;

arithmetic_expr
::= expr:e1 ADD expr:e2
    |
    expr:e1 SUB expr:e2
    |
    expr:e1 TIMES expr:e2
    |
    expr:e1 DIV expr:e2;

relational_expr
::= expr:e1 GREATER expr:e2
    |
    expr:e1 LESS expr:e2
    |
    expr:e1 GREATER_EQUAL expr:e2
    |
    expr:e1 LESS_EQUAL expr:e2
    |
    expr:e1 EQUAL expr:e2
    |
    expr:e1 NOT_EQUAL expr:e2;

expr_literal
::= STRING_LITERAL:v
    {: RESULT = v; :}
    |
    INTEGER_LITERAL:v
    {: RESULT = v; :}
    |
    CHAR_LITERAL:v
    {: RESULT = v; :}
    |
    DOUBLE_LITERAL:v
    {: RESULT = v; :}
    |
    TRUE:v
    {: RESULT = v; :}
    |
    FALSE:v
    {: RESULT = v; :};
