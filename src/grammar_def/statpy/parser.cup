package parsers.statpy;
import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.HashMap;

parser code
{:
    public void syntax_error(Symbol s){
        main.ParserState.output.add("Error Sintáctico en la Línea " + (s.left) +
                " Columna "+s.right+ ". No se esperaba este componente: " +s.value+"."); 
    }

    public void unrecovered_syntax_error(Symbol s){ 
        main.ParserState.output.add("Error síntactico irrecuperable en la Línea " + 
                (s.left)+ " Columna "+s.right+". Componente " + s.value + 
                " no reconocido."); 
    }

    String title;
    String titleX;
    String titleY;
    Object[] valueArray;
    Object[] titleArray;
    HashMap<String, String> symbol_table = new HashMap<>();
:}

terminal String LPAREN, RPAREN, ADD, SUB, DIV, TIMES, SEMICOLON, COMMA;
terminal String STRING_LITERAL, INTEGER_LITERAL, DOUBLE_LITERAL, CHAR_LITERAL;
terminal String STRING, INTEGER, DOUBLE, CHAR, BOOL;
terminal String TRUE, FALSE, AND, OR, NOT, ASSIGN, ID;
terminal String GREATER, LESS, GREATER_EQUAL, LESS_EQUAL, EQUAL, NOT_EQUAL;
terminal String MINUS, PRINT, VOID, MAIN, LBRACKET, RBRACKET;
terminal String FOR, INC, WHILE, DO, SWITCH, CASE, DEFAULT, COLON, BREAK;
terminal String IF, ELSE;
terminal String SQR_BRACKETS, EJEX, VALORES, TITULO, TITULOX, TITULOY;
terminal String DEFINIR_GLOBALES, GRAFICA_BARRAS, GRAFICA_PIE;
terminal String DOLLAR, NEW_VALOR;

non terminal document;
non terminal String expr, binary_expr, unary_expr;
non terminal String expr_literal, arithmetic_expr, relational_expr;
non terminal LinkedList stmts, stmt;
non terminal variable_stmt, print_stmt, type;
non terminal for_stmt, while_stmt, do_while_stmt, switch_stmt;
non terminal cases, case, default_case;
non terminal if_stmt, else_stmt, elif_stmt, continue_if;
non terminal define_global_vars, bar_graph, pie_graph;
non terminal bar_graph_body, pie_graph_body;
non terminal LinkedList list_items;
non terminal bar_graph_options, pie_graph_options;
non terminal String json_value;
non terminal global_vars, var_assignment, var_declaration;
non terminal String translation_exp;

precedence left GREATER, GREATER_EQUAL, LESS, LESS_EQUAL, EQUAL, NOT_EQUAL;
precedence left AND, OR;
precedence left NOT;
precedence left ADD, SUB;
precedence left TIMES, DIV;
precedence left MINUS;

document
::= VOID MAIN LPAREN RPAREN LBRACKET stmts RBRACKET
    {: main.ParserState.output.add("--Parseo finalizado--"); :};

stmts
::= stmts stmt:v
    {: RESULT = v; :}
    |
    stmt:v
    {: RESULT = v; :};

stmt
::= variable_stmt:v SEMICOLON
    |
    print_stmt SEMICOLON
    |
    if_stmt
    |
    for_stmt
    |
    while_stmt
    |
    do_while_stmt SEMICOLON
    |
    switch_stmt
    |
    BREAK SEMICOLON
    |
    define_global_vars
    |
    bar_graph
    |
    pie_graph;

//---INICIO SECCION DE GRAFICAS---
translation_exp
::= expr_literal:v
    {: RESULT = v; :}
    |
    ID:key
    {:
        try{
            RESULT = symbol_table.get(key.toLowerCase());
        }
        catch(Exception e){
            main.ParserState.output.add("Error en ("+keyleft+", "+keyright+"): "+key.toLowerCase()+" no existe");
        }
    :}
    |
    json_value:v
    {: RESULT = v; :};

json_value
::= DOLLAR LBRACKET NEW_VALOR COMMA STRING_LITERAL:file COMMA STRING_LITERAL:key RBRACKET
    {:
        try{
            RESULT = (String) main.ParserState.json_files.get(file.toLowerCase()).get(key.toLowerCase());
        }
        catch(Exception e){
            main.ParserState.output.add("Error en ("+keyleft+", "+keyright+"): "+key.toLowerCase()+" no existe");
        }
    :};

define_global_vars
::= VOID DEFINIR_GLOBALES LPAREN RPAREN LBRACKET global_vars RBRACKET;

global_vars
::= global_vars type ID:k ASSIGN translation_exp:v SEMICOLON
    {: symbol_table.put(k.toLowerCase(), v); :}
    |
    type ID:k ASSIGN translation_exp:v SEMICOLON
    {: symbol_table.put(k.toLowerCase(), v); :};

bar_graph
::= VOID GRAFICA_BARRAS LPAREN RPAREN LBRACKET bar_graph_body RBRACKET
    {: graph.general.barras(title, titleX, titleY, valueArray, titleArray); :};

bar_graph_body
::= bar_graph_body bar_graph_options
    |
    bar_graph_options;

bar_graph_options
::= STRING TITULO ASSIGN translation_exp:v SEMICOLON
    {: title = v; :}
    |
    STRING TITULOX ASSIGN translation_exp:v SEMICOLON
    {: titleX = v; :}
    |
    STRING TITULOY ASSIGN translation_exp:v SEMICOLON
    {: titleY = v; :}
    |
    STRING SQR_BRACKETS EJEX ASSIGN LBRACKET list_items:arr RBRACKET SEMICOLON
    {:
        titleArray = arr.toArray();
    :}
    |
    DOUBLE SQR_BRACKETS VALORES ASSIGN LBRACKET list_items:arr RBRACKET SEMICOLON
    {:
        valueArray = arr.toArray();
    :};

pie_graph
::= VOID GRAFICA_PIE LPAREN RPAREN LBRACKET pie_graph_body RBRACKET
    {: graph.general.pie(title, valueArray, titleArray); :};

pie_graph_body
::= pie_graph_body pie_graph_options
    |
    pie_graph_options;

pie_graph_options
::= STRING TITULO ASSIGN translation_exp:v SEMICOLON
    {: title = v; :}
    |
    STRING SQR_BRACKETS EJEX ASSIGN LBRACKET list_items:arr RBRACKET SEMICOLON
    {:
        titleArray = arr.toArray();
    :}
    |
    DOUBLE SQR_BRACKETS VALORES ASSIGN LBRACKET list_items:arr RBRACKET SEMICOLON
    {:
        valueArray = arr.toArray();
    :};

list_items
::= list_items:list COMMA translation_exp:item
    {:
        list.add(item);
        RESULT = list;
    :}
    |
    translation_exp:item
    {:
        LinkedList list = new LinkedList();
        list.add(item);
        RESULT = list;
    :};
//---FIN SECCION DE GRAFICAS---

variable_stmt
::= var_declaration:v
    {: RESULT = v; :}
    |
    var_assignment;

var_declaration
::= type ID:k ASSIGN expr:v
    {: RESULT = ""; :}
    |
    type ID:k
    {: RESULT = ""; :};

var_assignment
::= ID ASSIGN expr;

print_stmt
::= PRINT LPAREN expr:e RPAREN;

if_stmt
::= IF LPAREN expr RPAREN LBRACKET stmts RBRACKET continue_if else_stmt
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET continue_if
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET else_stmt
    |
    IF LPAREN expr RPAREN LBRACKET stmts RBRACKET;

continue_if
::= continue_if elif_stmt
    |
    elif_stmt;

elif_stmt
::= ELSE IF LPAREN expr RPAREN LBRACKET stmts RBRACKET;

else_stmt
::= ELSE LBRACKET stmts RBRACKET;

for_stmt
::= FOR LPAREN variable_stmt SEMICOLON expr SEMICOLON ID INC RPAREN LBRACKET stmts RBRACKET;

while_stmt
::= WHILE LPAREN expr RPAREN LBRACKET stmts RBRACKET;

do_while_stmt
::= DO LBRACKET stmts RBRACKET WHILE LPAREN expr RPAREN;

switch_stmt
::= SWITCH LPAREN expr RPAREN LBRACKET cases default_case RBRACKET;

cases
::= cases case
    |
    case;

case
::= CASE expr_literal COLON stmts;

default_case
::= DEFAULT COLON stmts;

type
::= INTEGER:v
    {: RESULT = v; :}
    |
    DOUBLE:v
    {: RESULT = v; :}
    |
    STRING:v
    {: RESULT = v; :}
    |
    CHAR:v
    {: RESULT = v; :}
    |
    VOID:v
    {: RESULT = v; :}
    |
    BOOL:v
    {: RESULT = v; :};

expr
::= binary_expr:v
    {: RESULT = v; :}
    |
    unary_expr:v
    {: RESULT = v; :}
    |
    LPAREN expr:v RPAREN
    {: RESULT = v; :}
    |
    expr_literal:v
    {: RESULT = v; :}
    |
    ID:v
    {: RESULT = v; :};

binary_expr
::= arithmetic_expr:v
    {: RESULT = v; :}
    |
    relational_expr:v
    {: RESULT = v; :}
    |
    expr:e1 AND expr:e2
    {: RESULT = "" + e1 + "and" + e2; :}
    |
    expr:e1 OR expr:e2
    {: RESULT = "" + e1 + "or" + e2; :};

unary_expr
::= NOT expr:e
    {: RESULT = "not" + e; :}
    |
    SUB expr:e 
    {: RESULT = "-" + e; :}
    %prec MINUS;

arithmetic_expr
::= expr:e1 ADD:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 SUB:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 TIMES:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 DIV:op expr:e2
    {: RESULT = "" + e1 + op + e2; :};

relational_expr
::= expr:e1 GREATER:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 LESS:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 GREATER_EQUAL:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 LESS_EQUAL:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 EQUAL:op expr:e2
    {: RESULT = "" + e1 + op + e2; :}
    |
    expr:e1 NOT_EQUAL:op expr:e2
    {: RESULT = "" + e1 + op + e2; :};

expr_literal
::= STRING_LITERAL:v
    {: RESULT = v; :}
    |
    INTEGER_LITERAL:v
    {: RESULT = v; :}
    |
    CHAR_LITERAL:v
    {: RESULT = v; :}
    |
    DOUBLE_LITERAL:v
    {: RESULT = v; :}
    |
    TRUE:v
    {: RESULT = v; :}
    |
    FALSE:v
    {: RESULT = v; :};
